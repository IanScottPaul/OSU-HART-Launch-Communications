
bare_rx_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00000412  000004a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000412  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  00800100  00800100  000004a6  2**0
                  ALLOC
  3 .stab         00000c3c  00000000  00000000  000004a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000e99  00000000  00000000  000010e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00001f7d  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001f90  2**2
                  CONTENTS, READONLY
  7 .debug_info   000009f4  00000000  00000000  00001fd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000096a  00000000  00000000  000029c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000332e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000371  00000000  00000000  00003348  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  10:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  14:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  18:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  1c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  20:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  24:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  28:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  2c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  30:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  34:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  38:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  3c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  40:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  44:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  48:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  4c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  50:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  54:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  58:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  5c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  60:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  64:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  68:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  6c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  70:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  74:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  78:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  7c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  80:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  84:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  88:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  8c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  90:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  94:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  98:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  9c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a0:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_clear_bss>:
  b8:	21 e0       	ldi	r18, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	01 c0       	rjmp	.+2      	; 0xc2 <.do_clear_bss_start>

000000c0 <.do_clear_bss_loop>:
  c0:	1d 92       	st	X+, r1

000000c2 <.do_clear_bss_start>:
  c2:	a6 30       	cpi	r26, 0x06	; 6
  c4:	b2 07       	cpc	r27, r18
  c6:	e1 f7       	brne	.-8      	; 0xc0 <.do_clear_bss_loop>
  c8:	0e 94 28 01 	call	0x250	; 0x250 <main>
  cc:	0c 94 07 02 	jmp	0x40e	; 0x40e <_exit>

000000d0 <__bad_interrupt>:
  d0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d4 <tx_when_ready>:
//FUNCTIONS//
//
//
//void tx_when_ready(uint8_t, char, char, char, char);
//this function takes full control of the uC during the SPI tranmission. 
void tx_when_ready(uint8_t address, char c0, char c1, char c2, char c3){//no array for readablility of main
  d4:	0f 93       	push	r16
  d6:	cf 93       	push	r28
  d8:	df 93       	push	r29
  da:	00 d0       	rcall	.+0      	; 0xdc <tx_when_ready+0x8>
  dc:	00 d0       	rcall	.+0      	; 0xde <tx_when_ready+0xa>
  de:	cd b7       	in	r28, 0x3d	; 61
  e0:	de b7       	in	r29, 0x3e	; 62
	while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
  e2:	0d b4       	in	r0, 0x2d	; 45
  e4:	07 fe       	sbrs	r0, 7
  e6:	fd cf       	rjmp	.-6      	; 0xe2 <tx_when_ready+0xe>
	uint8_t i;
	char word[4];
	word[0] = c0;
  e8:	69 83       	std	Y+1, r22	; 0x01
	word[1] = c1;
  ea:	4a 83       	std	Y+2, r20	; 0x02
	word[2] = c2;
  ec:	2b 83       	std	Y+3, r18	; 0x03
	word[3] = c3;
  ee:	0c 83       	std	Y+4, r16	; 0x04
	PORTB = (PORTB & ~(1<<0));//nss low for begining of packet transmission. 
  f0:	28 98       	cbi	0x05, 0	; 5
	SPDR = address;
  f2:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<7))){;}// this litteraly just does nothing until the spi isnt sending something. maybe make it flash arm2?
  f4:	0d b4       	in	r0, 0x2d	; 45
  f6:	07 fe       	sbrs	r0, 7
  f8:	fd cf       	rjmp	.-6      	; 0xf4 <tx_when_ready+0x20>
  fa:	fe 01       	movw	r30, r28
  fc:	31 96       	adiw	r30, 0x01	; 1
  fe:	9e 01       	movw	r18, r28
 100:	2b 5f       	subi	r18, 0xFB	; 251
 102:	3f 4f       	sbci	r19, 0xFF	; 255
	for(i=0;i<4;i++){
		SPDR = word[i];
 104:	81 91       	ld	r24, Z+
 106:	8e bd       	out	0x2e, r24	; 46
		while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
 108:	0d b4       	in	r0, 0x2d	; 45
 10a:	07 fe       	sbrs	r0, 7
 10c:	fd cf       	rjmp	.-6      	; 0x108 <tx_when_ready+0x34>
	word[2] = c2;
	word[3] = c3;
	PORTB = (PORTB & ~(1<<0));//nss low for begining of packet transmission. 
	SPDR = address;
	while(!(SPSR & (1<<7))){;}// this litteraly just does nothing until the spi isnt sending something. maybe make it flash arm2?
	for(i=0;i<4;i++){
 10e:	e2 17       	cp	r30, r18
 110:	f3 07       	cpc	r31, r19
 112:	c1 f7       	brne	.-16     	; 0x104 <tx_when_ready+0x30>
		SPDR = word[i];
		while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
	}
	PORTB |= (1<<0);//set nss high
 114:	28 9a       	sbi	0x05, 0	; 5
}
 116:	0f 90       	pop	r0
 118:	0f 90       	pop	r0
 11a:	0f 90       	pop	r0
 11c:	0f 90       	pop	r0
 11e:	df 91       	pop	r29
 120:	cf 91       	pop	r28
 122:	0f 91       	pop	r16
 124:	08 95       	ret

00000126 <set_mode_tx>:
//end tx when ready function description


//void set_mode_tx();
void set_mode_tx(){
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 126:	0d b4       	in	r0, 0x2d	; 45
 128:	07 fe       	sbrs	r0, 7
 12a:	fd cf       	rjmp	.-6      	; 0x126 <set_mode_tx>
	PORTB = (PORTB & ~(1<<0));	//nss low for begining of packet transmission. 
 12c:	28 98       	cbi	0x05, 0	; 5
	SPDR = 0b10000001;		//this says write mode address 0x01
 12e:	81 e8       	ldi	r24, 0x81	; 129
 130:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 132:	0d b4       	in	r0, 0x2d	; 45
 134:	07 fe       	sbrs	r0, 7
 136:	fd cf       	rjmp	.-6      	; 0x132 <set_mode_tx+0xc>
	SPDR = 0b00001100;		//mode register value for transmission mode. 
 138:	8c e0       	ldi	r24, 0x0C	; 12
 13a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 13c:	0d b4       	in	r0, 0x2d	; 45
 13e:	07 fe       	sbrs	r0, 7
 140:	fd cf       	rjmp	.-6      	; 0x13c <set_mode_tx+0x16>
	PORTB |= (1<<0);		//set nss high at end of transmission
 142:	28 9a       	sbi	0x05, 0	; 5
 144:	08 95       	ret

00000146 <set_mode_rx>:
}	
//void set_mode_rx();
void set_mode_rx(){
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 146:	0d b4       	in	r0, 0x2d	; 45
 148:	07 fe       	sbrs	r0, 7
 14a:	fd cf       	rjmp	.-6      	; 0x146 <set_mode_rx>
	PORTB = (PORTB & ~(1<<0));	//nss low for begining of packet transmission. 
 14c:	28 98       	cbi	0x05, 0	; 5
	SPDR = 0b10000001;		//this says write mode address 0x01
 14e:	81 e8       	ldi	r24, 0x81	; 129
 150:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 152:	0d b4       	in	r0, 0x2d	; 45
 154:	07 fe       	sbrs	r0, 7
 156:	fd cf       	rjmp	.-6      	; 0x152 <set_mode_rx+0xc>
	SPDR = 0b00010000;		//mode register value for reciever mode. 
 158:	80 e1       	ldi	r24, 0x10	; 16
 15a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<7))){;}	//this litteraly just waits until the spi isnt sending something.
 15c:	0d b4       	in	r0, 0x2d	; 45
 15e:	07 fe       	sbrs	r0, 7
 160:	fd cf       	rjmp	.-6      	; 0x15c <set_mode_rx+0x16>
	PORTB |= (1<<0);		//set nss high at end of transmission
 162:	28 9a       	sbi	0x05, 0	; 5
 164:	08 95       	ret

00000166 <read_fifo>:
}	
//void read_fifo(char*);
void read_fifo(char* current_char){	//no array for readablility of main
 166:	cf 93       	push	r28
 168:	df 93       	push	r29
 16a:	00 d0       	rcall	.+0      	; 0x16c <read_fifo+0x6>
 16c:	00 d0       	rcall	.+0      	; 0x16e <read_fifo+0x8>
 16e:	cd b7       	in	r28, 0x3d	; 61
 170:	de b7       	in	r29, 0x3e	; 62
	while(!(SPSR & (1<<7))){;}	// this litteraly just waits until the spi isnt sending something. 
 172:	0d b4       	in	r0, 0x2d	; 45
 174:	07 fe       	sbrs	r0, 7
 176:	fd cf       	rjmp	.-6      	; 0x172 <read_fifo+0xc>
	uint8_t i;
	char word[4];
	PORTB = (PORTB & ~(1<<0));	//nss low for begining of packet transmission. 
 178:	28 98       	cbi	0x05, 0	; 5
	SPDR = 0b00000000;		//read FIFO address command
 17a:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & (1<<7))){;}	// this litteraly just does nothing until the spi isnt sending something. maybe make it flash arm2?
 17c:	0d b4       	in	r0, 0x2d	; 45
 17e:	07 fe       	sbrs	r0, 7
 180:	fd cf       	rjmp	.-6      	; 0x17c <read_fifo+0x16>
 182:	fe 01       	movw	r30, r28
 184:	31 96       	adiw	r30, 0x01	; 1
 186:	9e 01       	movw	r18, r28
 188:	2b 5f       	subi	r18, 0xFB	; 251
 18a:	3f 4f       	sbci	r19, 0xFF	; 255
 18c:	df 01       	movw	r26, r30
	for(i=0;i<4;i++){
		word[i] = SPDR;
 18e:	4e b5       	in	r20, 0x2e	; 46
 190:	4d 93       	st	X+, r20
		while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
 192:	0d b4       	in	r0, 0x2d	; 45
 194:	07 fe       	sbrs	r0, 7
 196:	fd cf       	rjmp	.-6      	; 0x192 <read_fifo+0x2c>
	uint8_t i;
	char word[4];
	PORTB = (PORTB & ~(1<<0));	//nss low for begining of packet transmission. 
	SPDR = 0b00000000;		//read FIFO address command
	while(!(SPSR & (1<<7))){;}	// this litteraly just does nothing until the spi isnt sending something. maybe make it flash arm2?
	for(i=0;i<4;i++){
 198:	a2 17       	cp	r26, r18
 19a:	b3 07       	cpc	r27, r19
 19c:	c1 f7       	brne	.-16     	; 0x18e <read_fifo+0x28>
		word[i] = SPDR;
		while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
	}
	PORTB |= (1<<0);		//set nss high
 19e:	28 9a       	sbi	0x05, 0	; 5
 1a0:	dc 01       	movw	r26, r24
	for(i=0;i<4;i++){
	*(current_char + i) = word[i];
 1a2:	81 91       	ld	r24, Z+
 1a4:	8d 93       	st	X+, r24
	for(i=0;i<4;i++){
		word[i] = SPDR;
		while(!(SPSR & (1<<7))){;}// this litteraly just waits until the spi isnt sending something. 
	}
	PORTB |= (1<<0);		//set nss high
	for(i=0;i<4;i++){
 1a6:	e2 17       	cp	r30, r18
 1a8:	f3 07       	cpc	r31, r19
 1aa:	d9 f7       	brne	.-10     	; 0x1a2 <read_fifo+0x3c>
	*(current_char + i) = word[i];
	}
}
 1ac:	0f 90       	pop	r0
 1ae:	0f 90       	pop	r0
 1b0:	0f 90       	pop	r0
 1b2:	0f 90       	pop	r0
 1b4:	df 91       	pop	r29
 1b6:	cf 91       	pop	r28
 1b8:	08 95       	ret

000001ba <poll_comm_sw>:

//bool poll_comm_en();
bool poll_comm_sw(){
	static uint16_t comm_en_deb = 0;
	comm_en_deb = ((comm_en_deb << 1) | (!bit_is_clear(PINB,COMM_EN_SW)) | 0xe000);
 1ba:	43 b1       	in	r20, 0x03	; 3
 1bc:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <comm_en_deb.1969>
 1c0:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <comm_en_deb.1969+0x1>
 1c4:	22 0f       	add	r18, r18
 1c6:	33 1f       	adc	r19, r19
 1c8:	30 6e       	ori	r19, 0xE0	; 224
 1ca:	45 fb       	bst	r20, 5
 1cc:	88 27       	eor	r24, r24
 1ce:	80 f9       	bld	r24, 0
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	28 2b       	or	r18, r24
 1d4:	39 2b       	or	r19, r25
 1d6:	30 93 05 01 	sts	0x0105, r19	; 0x800105 <comm_en_deb.1969+0x1>
 1da:	20 93 04 01 	sts	0x0104, r18	; 0x800104 <comm_en_deb.1969>
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	21 30       	cpi	r18, 0x01	; 1
 1e2:	30 4f       	sbci	r19, 0xF0	; 240
 1e4:	08 f0       	brcs	.+2      	; 0x1e8 <poll_comm_sw+0x2e>
 1e6:	80 e0       	ldi	r24, 0x00	; 0
	if (comm_en_deb <= 0xF000){return true;}
	else return false;
}
 1e8:	08 95       	ret

000001ea <poll_arm_sw>:
//bool poll_arm_sw();
bool poll_arm_sw(){
	static uint16_t arm_sw_deb = 0;
	arm_sw_deb = ((arm_sw_deb << 1) | (!bit_is_clear(PINB,ARM_SW)) | 0xe000);
 1ea:	43 b1       	in	r20, 0x03	; 3
 1ec:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <arm_sw_deb.1972>
 1f0:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <arm_sw_deb.1972+0x1>
 1f4:	22 0f       	add	r18, r18
 1f6:	33 1f       	adc	r19, r19
 1f8:	30 6e       	ori	r19, 0xE0	; 224
 1fa:	46 fb       	bst	r20, 6
 1fc:	88 27       	eor	r24, r24
 1fe:	80 f9       	bld	r24, 0
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	28 2b       	or	r18, r24
 204:	39 2b       	or	r19, r25
 206:	30 93 03 01 	sts	0x0103, r19	; 0x800103 <arm_sw_deb.1972+0x1>
 20a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <arm_sw_deb.1972>
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	21 30       	cpi	r18, 0x01	; 1
 212:	30 4f       	sbci	r19, 0xF0	; 240
 214:	08 f0       	brcs	.+2      	; 0x218 <poll_arm_sw+0x2e>
 216:	80 e0       	ldi	r24, 0x00	; 0
	if (arm_sw_deb <= 0xF000){return true;}
	else return false;
}
 218:	08 95       	ret

0000021a <poll_launch_button>:
 21a:	86 b1       	in	r24, 0x06	; 6
 21c:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <_edata>
 220:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <_edata+0x1>
 224:	22 0f       	add	r18, r18
 226:	33 1f       	adc	r19, r19
 228:	30 6e       	ori	r19, 0xE0	; 224
 22a:	08 2e       	mov	r0, r24
 22c:	00 0c       	add	r0, r0
 22e:	99 0b       	sbc	r25, r25
 230:	88 27       	eor	r24, r24
 232:	99 0f       	add	r25, r25
 234:	88 1f       	adc	r24, r24
 236:	99 27       	eor	r25, r25
 238:	28 2b       	or	r18, r24
 23a:	39 2b       	or	r19, r25
 23c:	30 93 01 01 	sts	0x0101, r19	; 0x800101 <_edata+0x1>
 240:	20 93 00 01 	sts	0x0100, r18	; 0x800100 <_edata>
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	21 30       	cpi	r18, 0x01	; 1
 248:	30 4f       	sbci	r19, 0xF0	; 240
 24a:	08 f0       	brcs	.+2      	; 0x24e <poll_launch_button+0x34>
 24c:	80 e0       	ldi	r24, 0x00	; 0
 24e:	08 95       	ret

00000250 <main>:
//main is broken into primary two sections: Initialization and Loop
//in initialization:
//	 the state transition variable is set to IDLE
//	 the character array for recieved messages is initalized. 
//	 the boolean variables for the state machine are created and set false
uint8_t main(){	
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	cd b7       	in	r28, 0x3d	; 61
 256:	de b7       	in	r29, 0x3e	; 62
 258:	2c 97       	sbiw	r28, 0x0c	; 12
 25a:	0f b6       	in	r0, 0x3f	; 63
 25c:	f8 94       	cli
 25e:	de bf       	out	0x3e, r29	; 62
 260:	0f be       	out	0x3f, r0	; 63
 262:	cd bf       	out	0x3d, r28	; 61
/////////BEGIN GIPO INIT//////////
						//See system hardware documentation for GPIO connection
						//DDRX is data direction. 1 is output, 0 is input [DS:10.2]
						//PORTX will set the value to output, or the pullmode of the input. 1 is up 0 is down. 
						//PINX can be used to read the value of the input pins of X
		DDRC 	= 0b00000000;	//The only two pins on DDRC are inputs
 264:	17 b8       	out	0x07, r1	; 7
		DDRF	= 0xFF;		// all PORTF pins are outputs. 	
 266:	8f ef       	ldi	r24, 0xFF	; 255
 268:	80 bb       	out	0x10, r24	; 16
		DDRB 	= 0b00000111;	//PB6 input for the arm switch, PB[2:0] output for SPI 
 26a:	87 e0       	ldi	r24, 0x07	; 7
 26c:	84 b9       	out	0x04, r24	; 4
	    	//IOPORT B is X, ARM, COMM_EN, X, MISO, MOSI, SCK, NSS
		PORTC	= (1<<LAUNCH_BUTTON);	// set launch button to be pullup, RESET SENSE to be z 
 26e:	80 e8       	ldi	r24, 0x80	; 128
 270:	88 b9       	out	0x08, r24	; 8
		PORTB 	= ((1<<ARM_SW)|(1<<NSS)|(1<<COMM_EN_SW));// set arm sw to be pullup, write pull not slave select high
 272:	81 e6       	ldi	r24, 0x61	; 97
 274:	85 b9       	out	0x05, r24	; 5
	       	PORTF	= 0b11111100;		//just in case that statements ends up in the ignition, set fire to high.
 276:	8c ef       	ldi	r24, 0xFC	; 252
 278:	81 bb       	out	0x11, r24	; 17
//////////END GPIO INIT///////////////////////////
///////////BEGIN SPI INIT////////////////////////////////////////////////////////////////
		////SPRC////[DS:17.2.1]
		//Interupts disabled, SPI enabled, MSB first, Master mode
		//Low clk idle, fosh/64
		SPCR = 0b01010010;	//every bit in this register can be written. 
 27a:	82 e5       	ldi	r24, 0x52	; 82
 27c:	8c bd       	out	0x2c, r24	; 44
		SPSR = 0b00000000;	//only bit zero can be written in this reg so im not too worried about clobbering it here. 
 27e:	1d bc       	out	0x2d, r1	; 45
		default: 				state = STATE_IDLE;
			break;
		}//switch control
////////////////////END OF STATE MACHINE CONTROL CASES////////////////////////////////////////////////////////////////
//		character arrays for strcmp of messages. 
		char msg_tst_1[4] = {'t','s','e','t'};	
 280:	64 e7       	ldi	r22, 0x74	; 116
 282:	f6 2e       	mov	r15, r22
 284:	73 e7       	ldi	r23, 0x73	; 115
 286:	97 2e       	mov	r9, r23
 288:	15 e6       	ldi	r17, 0x65	; 101
		char msg_arm_1[4] = {'a','r','m','1'};	
		char msg_fire1[4] = {'f','i','r','e'};	
 28a:	e6 e6       	ldi	r30, 0x66	; 102
 28c:	ae 2e       	mov	r10, r30
 28e:	f9 e6       	ldi	r31, 0x69	; 105
 290:	bf 2e       	mov	r11, r31
 292:	a2 e7       	ldi	r26, 0x72	; 114
 294:	ea 2e       	mov	r14, r26
		default: 				state = STATE_IDLE;
			break;
		}//switch control
////////////////////END OF STATE MACHINE CONTROL CASES////////////////////////////////////////////////////////////////
//		character arrays for strcmp of messages. 
		char msg_tst_1[4] = {'t','s','e','t'};	
 296:	fd 82       	std	Y+5, r15	; 0x05
 298:	9e 82       	std	Y+6, r9	; 0x06
 29a:	1f 83       	std	Y+7, r17	; 0x07
 29c:	f8 86       	std	Y+8, r15	; 0x08
		char msg_arm_1[4] = {'a','r','m','1'};	
		char msg_fire1[4] = {'f','i','r','e'};	
 29e:	a9 82       	std	Y+1, r10	; 0x01
 2a0:	ba 82       	std	Y+2, r11	; 0x02
 2a2:	eb 82       	std	Y+3, r14	; 0x03
 2a4:	1c 83       	std	Y+4, r17	; 0x04
			//idle functionality
			//communications_enabled = poll_comm_sw();
			break;
		case(STATE_ESTABLISH):
			//establish functionality
			set_mode_rx();
 2a6:	0e 94 a3 00 	call	0x146	; 0x146 <set_mode_rx>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2aa:	8f e1       	ldi	r24, 0x1F	; 31
 2ac:	9e e4       	ldi	r25, 0x4E	; 78
 2ae:	01 97       	sbiw	r24, 0x01	; 1
 2b0:	f1 f7       	brne	.-4      	; 0x2ae <main+0x5e>
 2b2:	00 c0       	rjmp	.+0      	; 0x2b4 <main+0x64>
 2b4:	00 00       	nop
 2b6:	9f ef       	ldi	r25, 0xFF	; 255
 2b8:	22 e5       	ldi	r18, 0x52	; 82
 2ba:	87 e0       	ldi	r24, 0x07	; 7
 2bc:	91 50       	subi	r25, 0x01	; 1
 2be:	20 40       	sbci	r18, 0x00	; 0
 2c0:	80 40       	sbci	r24, 0x00	; 0
 2c2:	e1 f7       	brne	.-8      	; 0x2bc <main+0x6c>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <main+0x76>
 2c6:	00 00       	nop
			_delay_ms(TRANSITON_TIME);
			_delay_ms(RX_TIME);
			read_fifo(message);
 2c8:	ce 01       	movw	r24, r28
 2ca:	09 96       	adiw	r24, 0x09	; 9
 2cc:	0e 94 b3 00 	call	0x166	; 0x166 <read_fifo>
			if(strcmp(message, msg_tst_1)){
 2d0:	be 01       	movw	r22, r28
 2d2:	6b 5f       	subi	r22, 0xFB	; 251
 2d4:	7f 4f       	sbci	r23, 0xFF	; 255
 2d6:	ce 01       	movw	r24, r28
 2d8:	09 96       	adiw	r24, 0x09	; 9
 2da:	0e 94 fe 01 	call	0x3fc	; 0x3fc <strcmp>
 2de:	89 2b       	or	r24, r25
 2e0:	d1 f2       	breq	.-76     	; 0x296 <main+0x46>
				communications_established = true;
				set_mode_tx();
 2e2:	0e 94 93 00 	call	0x126	; 0x126 <set_mode_tx>
 2e6:	8f e1       	ldi	r24, 0x1F	; 31
 2e8:	9e e4       	ldi	r25, 0x4E	; 78
 2ea:	01 97       	sbiw	r24, 0x01	; 1
 2ec:	f1 f7       	brne	.-4      	; 0x2ea <main+0x9a>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <main+0xa0>
 2f0:	00 00       	nop
				_delay_ms(TRANSITON_TIME);
				tx_when_ready(0x80,'T','A','C','K');// 0b10000000 is write mode for FIFO, hex 0x80
 2f2:	0b e4       	ldi	r16, 0x4B	; 75
 2f4:	23 e4       	ldi	r18, 0x43	; 67
 2f6:	41 e4       	ldi	r20, 0x41	; 65
 2f8:	64 e5       	ldi	r22, 0x54	; 84
 2fa:	80 e8       	ldi	r24, 0x80	; 128
 2fc:	0e 94 6a 00 	call	0xd4	; 0xd4 <tx_when_ready>
 300:	9f ef       	ldi	r25, 0xFF	; 255
 302:	20 e7       	ldi	r18, 0x70	; 112
 304:	82 e0       	ldi	r24, 0x02	; 2
 306:	91 50       	subi	r25, 0x01	; 1
 308:	20 40       	sbci	r18, 0x00	; 0
 30a:	80 40       	sbci	r24, 0x00	; 0
 30c:	e1 f7       	brne	.-8      	; 0x306 <main+0xb6>
 30e:	00 c0       	rjmp	.+0      	; 0x310 <main+0xc0>
 310:	00 00       	nop
 312:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <arm_sw_deb.1972>
 316:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <arm_sw_deb.1972+0x1>
		default: 				state = STATE_IDLE;
			break;
		}//switch control
////////////////////END OF STATE MACHINE CONTROL CASES////////////////////////////////////////////////////////////////
//		character arrays for strcmp of messages. 
		char msg_tst_1[4] = {'t','s','e','t'};	
 31a:	fd 82       	std	Y+5, r15	; 0x05
 31c:	9e 82       	std	Y+6, r9	; 0x06
 31e:	1f 83       	std	Y+7, r17	; 0x07
 320:	f8 86       	std	Y+8, r15	; 0x08
		char msg_arm_1[4] = {'a','r','m','1'};	
		char msg_fire1[4] = {'f','i','r','e'};	
 322:	a9 82       	std	Y+1, r10	; 0x01
 324:	ba 82       	std	Y+2, r11	; 0x02
 326:	eb 82       	std	Y+3, r14	; 0x03
 328:	1c 83       	std	Y+4, r17	; 0x04
	else return false;
}
//bool poll_arm_sw();
bool poll_arm_sw(){
	static uint16_t arm_sw_deb = 0;
	arm_sw_deb = ((arm_sw_deb << 1) | (!bit_is_clear(PINB,ARM_SW)) | 0xe000);
 32a:	23 b1       	in	r18, 0x03	; 3
 32c:	26 fb       	bst	r18, 6
 32e:	cc 24       	eor	r12, r12
 330:	c0 f8       	bld	r12, 0
 332:	d1 2c       	mov	r13, r1
 334:	88 0f       	add	r24, r24
 336:	99 1f       	adc	r25, r25
 338:	90 6e       	ori	r25, 0xE0	; 224
 33a:	8c 29       	or	r24, r12
 33c:	9d 29       	or	r25, r13
 33e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <arm_sw_deb.1972+0x1>
 342:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <arm_sw_deb.1972>
				if(communications_established)		{state = STATE_READY;}//if comm est
				else					{state = STATE_IDLE;}//else comm est
			break;
		case(STATE_READY):
				if(!communications_established)	{state = STATE_ESTABLISH;}
				else if(arm_signal_decoded)	{state = STATE_ARMED;}//IF ARM SW DEB
 346:	81 30       	cpi	r24, 0x01	; 1
 348:	20 ef       	ldi	r18, 0xF0	; 240
 34a:	92 07       	cpc	r25, r18
 34c:	30 f7       	brcc	.-52     	; 0x31a <main+0xca>
 34e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 352:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
		default: 				state = STATE_IDLE;
			break;
		}//switch control
////////////////////END OF STATE MACHINE CONTROL CASES////////////////////////////////////////////////////////////////
//		character arrays for strcmp of messages. 
		char msg_tst_1[4] = {'t','s','e','t'};	
 356:	fd 82       	std	Y+5, r15	; 0x05
 358:	9e 82       	std	Y+6, r9	; 0x06
 35a:	1f 83       	std	Y+7, r17	; 0x07
 35c:	f8 86       	std	Y+8, r15	; 0x08
		char msg_arm_1[4] = {'a','r','m','1'};	
		char msg_fire1[4] = {'f','i','r','e'};	
 35e:	a9 82       	std	Y+1, r10	; 0x01
 360:	ba 82       	std	Y+2, r11	; 0x02
 362:	eb 82       	std	Y+3, r14	; 0x03
 364:	1c 83       	std	Y+4, r17	; 0x04
	else return false;
}
//bool poll_launch_button();
bool poll_launch_button(){
	static uint16_t lb_deb = 0;
	lb_deb = ((lb_deb << 1) | (!bit_is_clear(PINC,LAUNCH_BUTTON)) | 0xe000);
 366:	46 b1       	in	r20, 0x06	; 6
 368:	88 0f       	add	r24, r24
 36a:	99 1f       	adc	r25, r25
 36c:	9c 01       	movw	r18, r24
 36e:	30 6e       	ori	r19, 0xE0	; 224
 370:	84 2f       	mov	r24, r20
 372:	44 0f       	add	r20, r20
 374:	99 0b       	sbc	r25, r25
 376:	88 27       	eor	r24, r24
 378:	99 0f       	add	r25, r25
 37a:	88 1f       	adc	r24, r24
 37c:	99 27       	eor	r25, r25
 37e:	82 2b       	or	r24, r18
 380:	93 2b       	or	r25, r19
 382:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <_edata+0x1>
 386:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
				if(!communications_established)	{state = STATE_ESTABLISH;}
				else if(arm_signal_decoded)	{state = STATE_ARMED;}//IF ARM SW DEB
				else				{state = STATE_READY;}//else arm sw deb
			break;
		case(STATE_ARMED):
				if (launch_button_debounced)		{state = STATE_FIREING;}
 38a:	81 30       	cpi	r24, 0x01	; 1
 38c:	20 ef       	ldi	r18, 0xF0	; 240
 38e:	92 07       	cpc	r25, r18
 390:	10 f7       	brcc	.-60     	; 0x356 <main+0x106>
		}//switch control
////////////////////END OF STATE MACHINE CONTROL CASES////////////////////////////////////////////////////////////////
//		character arrays for strcmp of messages. 
		char msg_tst_1[4] = {'t','s','e','t'};	
		char msg_arm_1[4] = {'a','r','m','1'};	
		char msg_fire1[4] = {'f','i','r','e'};	
 392:	a9 82       	std	Y+1, r10	; 0x01
 394:	ba 82       	std	Y+2, r11	; 0x02
 396:	eb 82       	std	Y+3, r14	; 0x03
 398:	1c 83       	std	Y+4, r17	; 0x04
			break;	
		case(STATE_ARMED):
			launch_button_debounced = poll_launch_button();
			break;
		case(STATE_FIREING):
			set_mode_tx();
 39a:	0e 94 93 00 	call	0x126	; 0x126 <set_mode_tx>
			tx_when_ready(0x80,'f','i','r','e');
 39e:	05 e6       	ldi	r16, 0x65	; 101
 3a0:	22 e7       	ldi	r18, 0x72	; 114
 3a2:	49 e6       	ldi	r20, 0x69	; 105
 3a4:	66 e6       	ldi	r22, 0x66	; 102
 3a6:	80 e8       	ldi	r24, 0x80	; 128
 3a8:	0e 94 6a 00 	call	0xd4	; 0xd4 <tx_when_ready>
 3ac:	9f ef       	ldi	r25, 0xFF	; 255
 3ae:	20 e7       	ldi	r18, 0x70	; 112
 3b0:	82 e0       	ldi	r24, 0x02	; 2
 3b2:	91 50       	subi	r25, 0x01	; 1
 3b4:	20 40       	sbci	r18, 0x00	; 0
 3b6:	80 40       	sbci	r24, 0x00	; 0
 3b8:	e1 f7       	brne	.-8      	; 0x3b2 <main+0x162>
 3ba:	00 c0       	rjmp	.+0      	; 0x3bc <main+0x16c>
 3bc:	00 00       	nop
			_delay_ms(TX_TIME);//allow time to tx
			set_mode_rx();
 3be:	0e 94 a3 00 	call	0x146	; 0x146 <set_mode_rx>
 3c2:	8f e1       	ldi	r24, 0x1F	; 31
 3c4:	9e e4       	ldi	r25, 0x4E	; 78
 3c6:	01 97       	sbiw	r24, 0x01	; 1
 3c8:	f1 f7       	brne	.-4      	; 0x3c6 <main+0x176>
 3ca:	00 c0       	rjmp	.+0      	; 0x3cc <main+0x17c>
 3cc:	00 00       	nop
 3ce:	9f ef       	ldi	r25, 0xFF	; 255
 3d0:	22 e5       	ldi	r18, 0x52	; 82
 3d2:	87 e0       	ldi	r24, 0x07	; 7
 3d4:	91 50       	subi	r25, 0x01	; 1
 3d6:	20 40       	sbci	r18, 0x00	; 0
 3d8:	80 40       	sbci	r24, 0x00	; 0
 3da:	e1 f7       	brne	.-8      	; 0x3d4 <main+0x184>
 3dc:	00 c0       	rjmp	.+0      	; 0x3de <main+0x18e>
 3de:	00 00       	nop
			_delay_ms(TRANSITON_TIME);
			_delay_ms(RX_TIME);
			read_fifo(message);
 3e0:	ce 01       	movw	r24, r28
 3e2:	09 96       	adiw	r24, 0x09	; 9
 3e4:	0e 94 b3 00 	call	0x166	; 0x166 <read_fifo>
			if(strcmp(message, msg_fire1)){
 3e8:	be 01       	movw	r22, r28
 3ea:	6f 5f       	subi	r22, 0xFF	; 255
 3ec:	7f 4f       	sbci	r23, 0xFF	; 255
 3ee:	ce 01       	movw	r24, r28
 3f0:	09 96       	adiw	r24, 0x09	; 9
 3f2:	0e 94 fe 01 	call	0x3fc	; 0x3fc <strcmp>
		case(STATE_ARMED):
				if (launch_button_debounced)		{state = STATE_FIREING;}
				else 					{state = STATE_ARMED;}
			break;
		case(STATE_FIREING):
				if(fire_ackd)		{ state = STATE_FIRED;  }//if fire ackd
 3f6:	89 2b       	or	r24, r25
 3f8:	61 f2       	breq	.-104    	; 0x392 <main+0x142>
 3fa:	4d cf       	rjmp	.-358    	; 0x296 <main+0x46>

000003fc <strcmp>:
 3fc:	fb 01       	movw	r30, r22
 3fe:	dc 01       	movw	r26, r24
 400:	8d 91       	ld	r24, X+
 402:	01 90       	ld	r0, Z+
 404:	80 19       	sub	r24, r0
 406:	01 10       	cpse	r0, r1
 408:	d9 f3       	breq	.-10     	; 0x400 <__LOCK_REGION_LENGTH__>
 40a:	99 0b       	sbc	r25, r25
 40c:	08 95       	ret

0000040e <_exit>:
 40e:	f8 94       	cli

00000410 <__stop_program>:
 410:	ff cf       	rjmp	.-2      	; 0x410 <__stop_program>
